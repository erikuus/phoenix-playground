<p>
  The <code>Filter</code> module demonstrates real-time filtering using
  LiveView's <code>handle_event</code> mechanism rather than URL parameters.
  This approach maintains filter state in the socket assigns, providing instant
  feedback without page navigation while keeping the URL clean and unchanged.
</p>

<h3><code>mount/3</code></h3>
<ul>
  <li>
    Initializes the LiveView with a default filter state where all filter
    options are set to indicate no filtering is applied (<code>""</code> for
    text fields, <code>"false"</code> for checkboxes).
  </li>
  <li>
    With the default empty filter, all USA cities are loaded and displayed in
    the table, giving users the complete dataset to filter from.
  </li>
</ul>

<h4>Helpers for <code>mount/3</code></h4>
<ul>
  <li>
    <code>assign_filter/2</code> updates the socket with filtered city data from
    <code>Cities.list_country_city/2</code> and stores the current filter state
    for future comparisons.
  </li>
  <li>
    <code>get_default_filter/0</code> provides the initial filter state,
    ensuring consistency between mount and the filtering logic.
  </li>
</ul>

<h3><code>render/1</code></h3>
<ul>
  <li>
    Constructs a form with <code>phx-change="filter"</code> that triggers
    filtering on any input change, providing real-time filtering feedback.
  </li>
  <li>
    The name input includes <code>phx-debounce="500"</code> to throttle rapid
    keystrokes, preventing excessive database queries during typing.
  </li>
  <li>
    District options are populated by <code>get_district_options()</code>, which
    includes an empty string for "no filter" plus all unique USA districts.
  </li>
  <li>
    Size checkboxes use a dual-structure pattern from
    <code>get_size_options()</code> that handles the complex requirements of
    reliable checkbox state management in LiveView (explained in detail in the
    "Checkbox Pattern" section below).
  </li>
  <li>
    Conditionally renders either a "No results" alert or a data table based on
    whether <code>@cities</code> contains any matching records.
  </li>
</ul>

<h3><code>handle_event/3</code> for <code>"filter"</code></h3>
<ul>
  <li>
    Triggered whenever any form input changes, receiving all current form values
    in the event payload.
  </li>
  <li>
    Creates a new filter map from the received parameters and compares it
    against the current <code>socket.assigns.filter</code> to avoid unnecessary
    updates.
  </li>
  <li>
    Only calls <code>assign_filter/2</code> when the filter actually changes,
    optimizing performance by preventing redundant database queries.
  </li>
  <li>
    Relies on Phoenix's <code>&lt;.input type="checkbox"&gt;</code> component's
    guaranteed behavior: checkbox values are always strings
    <code>"true"</code> or <code>"false"</code> (see "The Checkbox Pattern"
    section below for why this matters).
  </li>
</ul>

<h4>Helpers for <code>render/1</code></h4>
<ul>
  <li>
    <code>get_district_options/0</code> returns district options for the select
    input, following the <code>get_</code> prefix convention for
    value-retrieving functions.
  </li>
  <li>
    <code>get_size_options/0</code> demonstrates the essential dual-structure
    pattern for LiveView checkboxes, containing both <code>key</code> (atom for
    assigns access) and <code>name</code> (string for form submission).
  </li>
</ul>

<h3>The Checkbox Pattern: Critical Implementation Detail</h3>
<p>
  This module showcases a sophisticated but non-intuitive pattern essential for
  reliable checkbox handling in Phoenix LiveView. Understanding this pattern is
  crucial for any LiveView application using checkboxes.
</p>

<h4>The Core Problem</h4>
<p>
  HTML checkboxes have inconsistent form submission behavior that breaks
  LiveView's pattern matching expectations:
</p>
<ul>
  <li>
    <strong>Checked checkbox:</strong> Submits <code>name=value</code> in form
    data
  </li>
  <li>
    <strong>Unchecked checkbox:</strong> Submits nothing (key doesn't exist)
  </li>
</ul>
<p>
  This inconsistency would cause <code>handle_event/3</code> pattern matching to
  fail when checkboxes are unchecked, as the expected keys would be missing from
  the payload.
</p>

<h4>Phoenix's Solution</h4>
<p>
  Phoenix's checkbox component solves this by generating two HTML inputs per
  checkbox:
</p>
<pre><code>&lt;input type="hidden" name="sm" value="false" /&gt;
&lt;input type="checkbox" name="sm" value="true" /&gt;</code></pre>
<p>This ensures consistent form submission:</p>
<ul>
  <li>
    <strong>Unchecked:</strong> Only hidden input submits →
    <code>"sm" => "false"</code>
  </li>
  <li>
    <strong>Checked:</strong> Checkbox overrides hidden input →
    <code>"sm" => "true"</code>
  </li>
</ul>

<h4>The Dual Key/Name Structure</h4>
<p>
  The <code>get_size_options/0</code> function returns maps with three fields
  that serve different purposes:
</p>
<pre><code>%{key: :sm, name: "sm", label: "Small"}</code></pre>
<ul>
  <li>
    <code>name</code>: The checkbox's HTML name attribute (used for form
    submission)
  </li>
  <li><code>label</code>: The text displayed next to the checkbox</li>
  <li>
    <code>key</code>: Used to retrieve the checkbox's current value from the
    filter assigns
  </li>
</ul>

<h4>Why We Need Both <code>name</code> and <code>key</code></h4>
<p>
  At first glance, having both <code>name: "sm"</code> and
  <code>key: :sm</code> seems redundant, but each serves a distinct purpose:
</p>
<ul>
  <li>
    <strong><code>name</code> (string):</strong> Required for the HTML checkbox
    and pattern matching in <code>handle_event/3</code>
  </li>
  <li>
    <strong><code>key</code> (atom):</strong> Required to get the current
    checkbox value from <code>@filter</code> assigns
  </li>
</ul>

<h4>Template Implementation</h4>
<p>In the template, you can see both in action:</p>
<pre><code>&lt;.input :for={size &lt;- get_size_options()}
         type="checkbox"
         label={size.label}        # "Small", "Medium", "Large"
         name={size.name}          # "sm", "md", "lg" (for form submission)
         value={@filter[size.key]} # @filter[:sm], @filter[:md], @filter[:lg]
/&gt;</code></pre>
<p>
  The <code>value</code> attribute gets the current state ("true" or "false")
  from the filter assigns to determine if the checkbox should be checked or
  unchecked when the page renders.
</p>

<hr />

<h2>cities.ex</h2>

<h3><code>list_country_city/2</code></h3>
<p>
  This function demonstrates Ecto's pipe-friendly query functions to build SQL
  step by step.
</p>

<h4>Query Building Pipeline</h4>
<ul>
  <li>Starts with a base query for cities in the specified country code</li>
  <li>Pipes through filter functions that conditionally add WHERE clauses</li>
  <li>
    Each filter function returns the query unchanged if no filtering is needed
  </li>
</ul>

<h4><code>filter_by_name/2</code></h4>
<ul>
  <li>
    Uses pattern matching to only apply filtering when <code>name</code> is not
    empty
  </li>
  <li>
    Implements case-insensitive partial matching with <code>ilike/2</code>
  </li>
  <li>
    Uses the pin operator (<code>^</code>) to safely inject the search pattern
    into <code>ilike/2</code>
  </li>
</ul>

<h4><code>filter_by_district/2</code></h4>
<ul>
  <li>Uses exact string matching against the district field</li>
  <li>Only applies the filter when district is not an empty string</li>
</ul>

<h4><code>filter_by_size/2</code> - Dynamic Query Building</h4>

<ul>
  <li>
    This function uses Ecto's <code>dynamic/1</code> to build conditional WHERE
    clauses. While query pipelines add conditions to build queries,
    <code>dynamic/1</code> adds partial SQL fragments to build complex
    conditions.
  </li>
  <li>
    <code>dynamic/1</code> works like a basket that collects SQL condition
    fragments. You start with an empty basket, add pieces of WHERE logic, then
    dump the entire basket into your query at once.
  </li>
  <li>
    Given a filter map like <code>%{sm: "true", md: "true", lg: "true"}</code>,
    <code>filter_by_size/2</code> dynamically builds a SQL WHERE clause such as:
    <code
      >WHERE (c.population &lt;= 500000) OR ((c.population &gt; 500000) AND
      (c.population &lt; 1000000)) OR (c.population &gt;= 1000000)</code
    >
  </li>
</ul>

<h3><code>list_distinct_country_districts/1</code></h3>
<p>
  This function demonstrates an optimized approach for populating select
  options. Compare it to a less efficient alternative:
</p>

<pre><code># DON'T do this - returns full structs then extracts district
def list_distinct_country_district(countrycode) do
  from(City)
  |> select([:district])
  |> where(countrycode: ^countrycode)
  |> order_by(asc: :district)
  |> distinct(true)
  |> Repo.all()
end</code>

<code># Then in LiveView helper:
defp get_district_options() do
  ["" | Cities.list_distinct_country_district("USA") |> Enum.map(& &1.district)]
end</code>
</pre>
