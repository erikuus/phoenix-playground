<p>
  The <code>Search</code> module offers a search interface allowing users to
  search for countries without using URL parameters. Here's a breakdown:
</p>
<h3><code>mount/3</code></h3>
<ul>
  <li>
    Sets up initial state with empty search values using the
    <code>assign_empty_search/1</code> helper function.
  </li>
</ul>
<h3><code>assign_empty_search/1</code></h3>
<ul>
  <li>
    Centralizes the logic for resetting search state, ensuring consistent
    initialization in both <code>mount/3</code> and empty query handling.
  </li>
  <li>
    Sets <code>:query</code> to <code>nil</code>, <code>:countries</code> to an
    empty list, and <code>:loading</code> to <code>false</code>.
  </li>
</ul>
<h3><code>render/1</code></h3>
<ul>
  <li>
    Constructs the search form with an input field for the query and a button to
    submit the search.
  </li>
  <li>
    The <code>phx-submit="search"</code> event is bound to the form submission,
    triggering the <code>"search"</code> event.
  </li>
  <li>
    The <code>disabled={@loading}</code> property on the input and button
    elements ensures that users cannot interact with them while the search is
    processing.
  </li>
  <li>
    An alert is conditionally displayed if there's a
    <code>"no_result"</code> flash message, indicating no results found or
    prompting for a search term.
  </li>
  <li>
    A table displays search results using a custom table component with columns
    for country details.
  </li>
</ul>
<h3><code>handle_event/3</code> for <code>"search"</code></h3>
<ul>
  <li>
    If the search query is empty, it rejects the search attempt by providing
    user feedback (flash message) and resetting to a clean state. This prevents
    unnecessary processing and guides users toward valid input.
  </li>
  <li>
    For a non-empty query, it immediately:
    <ul>
      <li>
        Sends a message to itself (<code>{:find, query}</code>) to process the
        search asynchronously. This pattern prevents the LiveView process from
        blocking during the search operation, keeping the UI responsive.
      </li>
      <li>
        Sets <code>loading: true</code> to show visual feedback and disable the
        form controls.
      </li>
      <li>Clears any existing flash messages to remove stale notifications.</li>
    </ul>
  </li>
</ul>
<h3><code>handle_info/2</code> for <code>{:find, query}</code></h3>
<ul>
  <li>
    Includes a simulated delay (<code>Process.sleep(@demo_delay)</code>) to
    demonstrate the loading state behavior. In production, this would be
    replaced with actual database queries or API calls.
  </li>
  <li>Performs the search using <code>Countries.list_country(query)</code>.</li>
  <li>
    Handles two outcomes:
    <ul>
      <li>
        <strong>No results found:</strong> Sets a <code>"no_result"</code> flash
        message and turns off the loading state, re-enabling the form controls.
      </li>
      <li>
        <strong>Results found:</strong> Updates the
        <code>:countries</code> assign with the search results and turns off the
        loading state.
      </li>
    </ul>
  </li>
  <li>
    Setting <code>loading: false</code> in both cases re-enables the disabled
    form controls, allowing users to perform new searches.
  </li>
</ul>
<h3>Key Implementation Pattern</h3>
<ul>
  <li>
    <strong>Disabled UI During Loading:</strong> This example demonstrates
    preventing concurrent searches by disabling form controls while
    <code>@loading</code> is true. This ensures users cannot trigger multiple
    searches simultaneously, avoiding race conditions and providing clear
    feedback about the current state.
  </li>
  <li>
    <strong>Async Message Handling:</strong> The
    <code>send(self(), {:find, query})</code>
    pattern allows the search to be processed asynchronously without blocking
    the LiveView process. This keeps the UI responsive and enables the loading
    state to be displayed immediately.
  </li>
</ul>
