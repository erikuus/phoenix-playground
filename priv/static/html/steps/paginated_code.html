<p>
  The <code>LivePlaygroundWeb.StepsLive.Paginated.Index</code> module is a
  Phoenix LiveView that manages a paginated list of languages. It incorporates
  real-time updates, pagination controls, and concurrency considerations to
  provide a seamless user experience.
</p>
<h3><code>mount/3</code></h3>
<p>
  <strong>Why Two <code>mount/3</code> Functions?</strong>
</p>
<ul>
  <li>
    <strong>Handling URL Manipulations</strong>: Users can manipulate the URL to
    include parameters that may be invalid or out of range. By using two
    <code>mount/3</code> functions with pattern matching, we cleanly separate
    the cases where pagination parameters are provided and where they are not.
  </li>
  <li>
    <strong>Validation Before Initialization</strong>: When parameters are
    provided, we need to validate them before initializing the LiveView state.
    This ensures that the LiveView is always in a consistent state, even if the
    user inputs invalid parameters.
  </li>
</ul>
<p>
  <strong>First <code>mount/3</code> Function (With Parameters)</strong>
</p>
<ul>
  <li>
    If the socket is connected, we subscribe to language updates using
    <code>Languages2.subscribe()</code>. This subscription allows the LiveView
    to receive real-time notifications whenever languages are added, updated, or
    deleted.
  </li>
  <li>
    If the validated <code>page</code> differs from the provided
    <code>page</code>, we redirect the user to the correct URL using
    <code>push_navigate</code>. This ensures that the URL in the browser
    accurately reflects the current state of the LiveView. Without this
    redirection, the URL would remain unchanged even after validation.
  </li>
</ul>
<p>
  <strong>Second <code>mount/3</code> Function (Without Parameters)</strong>
</p>
<ul>
  <li>
    We set default values for
    <code>page</code> and <code>per_page</code>.
  </li>
  <li>We call the <code>init/2</code> function with these default options.</li>
</ul>
<h3><code>validate_options/2</code></h3>
<p>
  Ensures that <code>page</code> and <code>per_page</code> are valid integers
  within acceptable ranges.
</p>
<ul>
  <li>
    <p>
      The <code>validate_options/2</code> function sanitizes the pagination
      parameters. Instead of using <code>String.to_integer/1</code>, it employs
      a custom <code>to_integer/2</code> function. This custom function safely
      parses integers and defaults to specified values if parsing fails,
      preventing errors from invalid input.
    </p>
    <p>
      After parsing, the function calls <code>get_existing_page/3</code>, which
      uses <code>ceil_div/2</code> to calculate the maximum number of pages
      based on the total item count and the <code>per_page</code> value. For
      example, if there are 45 items and <code>per_page</code> is set to 10,
      <code>ceil_div</code> computes that there should be 5 pages. If a user
      requests page 6, <code>get_existing_page</code>
      adjusts the page number to 5 to ensure it doesn't exceed the available
      range.
    </p>
  </li>
  <li>
    If <code>per_page</code> is not one of the allowed options, it defaults to
    <code>@per_page</code>.
  </li>
</ul>
<h3><code>init/2</code></h3>
<p>
  We use two separate <code>mount/3</code> functions to handle scenarios with
  and without pagination parameters. To avoid duplicating the common setup code
  in both functions, we abstract the shared logic into an
  <code>init/2</code> function.
</p>
<ol>
  <li>
    <p>
      <strong><code>:options</code></strong
      >: Stores the current pagination options (<code>page</code> and
      <code>per_page</code>).
    </p>
  </li>
  <li>
    <p>
      Having three separate count variables—<code>:count_all</code>,
      <code>:count_all_summary</code>, and <code>:count_all_pagination</code>—is
      crucial for maintaining a seamless and intuitive user experience.
    </p>
    <p>
      <code>:count_all</code> serves as the definitive count of all language
      items present in the database. It reflects the true state of the data at
      any given moment. Whenever a language is added or deleted,
      <code>:count_all</code> is immediately updated to mirror these changes.
    </p>
    <p>
      While <code>:count_all</code> provides the actual total count,
      <code>:count_all_summary</code> is specifically used for the summary
      display presented to the user, such as "Showing 1 - 5 of 100." The key
      reason for keeping <code>:count_all_summary</code> separate from
      <code>:count_all</code> lies in handling deletions gracefully.
    </p>
    <p>When a user deletes an item:</p>
    <ul>
      <li>
        <strong><code>:count_all</code></strong> decreases immediately to
        reflect the removal from the database.
      </li>
      <li>
        <strong><code>:count_all_summary</code></strong> remains unchanged
        because the deleted item is still visible on the current page, marked
        appropriately (e.g., with a badge, gray background, and strikethrough).
        This ensures that the summary accurately represents what the user sees.
      </li>
    </ul>
    <p>
      <code>:count_all_pagination</code> is essential for keeping the pagination
      controls consistent in the application. Unlike
      <code>:count_all_summary</code>, which can temporarily differ from
      <code>:count_all</code> when items are being deleted,
      <code>:count_all_pagination</code> ensures that the number of pages
      remains stable and only updates when necessary—such as when the user
      resorts the list, reloads, or navigates away.
    </p>
    <p>
      Using <code>:count_all_summary</code> directly for pagination would lead
      to inconsistencies. Consider the following scenario:
    </p>
    <ul>
      <li>There are 100 items distributed over 5 pages (20 items per page).</li>
      <li>
        After adding an item:
        <ul>
          <li><code>:count_all</code> increases to 101.</li>
          <li>
            <code>:count_all_summary</code> also increases to 101, updating the
            summary to display “Showing 1 - 6 of 101.”
          </li>
          <li>
            <code>:count_all_pagination</code> remains at 100 to prevent the
            immediate appearance of a 6th page.
          </li>
        </ul>
      </li>
    </ul>
    <p>
      This is because the new item fits into the existing pages by temporarily
      displaying 21 items on the current page (1-21), keeping all items within
      the original 5 pages. The 6th page only appears when the user resorts the
      list or navigates away and returns. At that point,
      <code>:count_all_pagination</code> is updated to reflect the new total
      count of 101, allowing the pagination to adjust appropriately.
    </p>
  </li>
  <li>
    <p>
      <strong><code>:count_visible_rows</code></strong> represents the number of
      items currently visible to the user on the page. This value can exceed the
      <code>per_page</code> limit temporarily when new items are added to the
      current view. For example, if <code>per_page</code> is set to 10 and a new
      item is added, <code>:count_visible_rows</code> becomes 11 to accommodate
      the newly added item. This ensures that the user sees the addition
      immediately without needing to resort or navigate away. Once the user
      resorts the list or moves to another page,
      <code>:count_visible_rows</code> returns to align with the
      <code>per_page</code> value, ensuring consistency in the pagination view.
    </p>
  </li>
  <li>
    <p>
      The <code>:pending_deletion</code> flag is set to <code>true</code> when
      items are marked as deleted in the UI but have already been removed from
      the database. When this flag is true, the summary section is grayed out to
      indicate that the displayed counts may not accurately reflect the current
      data.
    </p>
  </li>
  <li>
    <p>
      We initialize the stream of languages using <code>stream/3</code>.
      Initializing the stream in <code>init/2</code> allows the LiveView to
      establish the data stream once when the view mounts, rather than
      reinitializing it every time parameters change. This approach avoids
      unnecessary reloads.
    </p>
  </li>
</ol>
<h3><code>handle_param/3</code></h3>
<p>
  Manages updates to URL parameters and handles LiveView actions such as
  navigating between listing, editing, or creating new languages.
</p>
<p>Specifically, it performs two main tasks:</p>
<ul>
  <li>
    The <code>apply_action/3</code> function sets the appropriate state and data
    for listing, editing, or creating languages.
  </li>
  <li>
    The <code>apply_options/4</code> function updates pagination options and
    reloads the language list when necessary. Refer to the explanation below for
    more details.
  </li>
</ul>
<h3><code>apply_action/3</code></h3>
<p>
  This function configures the socket based on the current LiveView action.
  Depending on whether the user is viewing the index, editing a language, or
  creating a new one, this function assigns the appropriate state and data to
  the socket. For instance, if the user initiates an edit action,
  <code>apply_action/3</code> sets up the socket with the specific language data
  to be edited.
</p>

<h3><code>apply_options/4</code></h3>
<p>
  The <code>apply_options/4</code> function updates pagination options and
  reloads the language list when necessary. There are two versions of this
  function:
</p>
<ul>
  <li>
    <strong>Index Action (<code>:index</code>)</strong>:
    <p>
      Handles the main listing page where pagination is relevant. It updates
      options and reloads data when parameters change.
    </p>
  </li>
  <li>
    <strong>Other Actions</strong>:
    <p>
      For actions like <code>:edit</code> or <code>:new</code>, pagination isn't
      needed, so the function returns the socket unchanged.
    </p>
  </li>
</ul>
<p>
  Using pattern matching on <code>live_action</code> optimizes performance by
  avoiding unnecessary computations for actions where pagination doesn't apply.
</p>
<p>In the index version, we:</p>
<ol>
  <li>
    <strong>Extract Options and Parameters</strong>:
    <p>
      Retrieve current pagination options and extract <code>per_page</code> and
      <code>page</code> from parameters or use defaults.
    </p>
  </li>
  <li>
    <strong>Validate Parameters</strong>:
    <p>
      Convert <code>page</code> to an integer and validate options to ensure the
      page number is within valid bounds.
    </p>
  </li>
  <li>
    <strong>Check If Reload Is Needed</strong>:
    <p>Determine if data reload is necessary by checking if:</p>
    <ul>
      <li>
        <code>reset_stream</code> is true (user clicked "reset" to resort data).
      </li>
      <li>
        <code>new_options</code> differ from current options (user navigated to
        a new page or changed <code>per_page</code> value).
      </li>
      <li>
        The validated page number changed because the user requested an invalid
        page. For example, after deleting all items on page 5 and attempting to
        navigate to page 6, the validation adjusts the page number back to 5,
        which becomes the last valid page. Even though
        <code>new_options</code> and <code>options</code>
        both now point to page 5, we still need this extra condition to reset
        the stream and ensure the data is correctly displayed for the updated
        last page.
      </li>
    </ul>
  </li>
  <li>
    <strong>Reload Data and Update Socket</strong>:
    <p>
      If needed, fetch new data, update counts and options, reset the language
      stream.
    </p>
  </li>
  <li>
    <strong>Conditionally Update the URL</strong>:
    <p>
      The inline anonymous function conditionally applies
      <code>push_patch</code> to update the browser's URL without a full page
      reload when the validated page number differs from the original. This
      ensures the URL matches the current state, allowing users to bookmark or
      share the correct page.
    </p>
  </li>
  <li>
    <strong>Return Socket</strong>:
    <p>If no reload is needed, return the socket unchanged.</p>
  </li>
</ol>
<h3><code>handle_event/3</code></h3>
<p>
  Handles various user actions, ensuring the LiveView responds appropriately to
  interactions:
</p>
<ul>
  <li>
    <strong>"change-per-page"</strong>
    <p>
      When the user selects a new <code>per_page</code> value, it is updated in
      the socket's assigns, and <code>push_patch</code> is used to update the
      URL. This ensures that the browser URL always reflects the current
      pagination settings, allowing users to bookmark or share the correct view.
    </p>
  </li>
  <li>
    <strong>"reset-stream"</strong>
    <p>
      This action is triggered by a link displayed in flash messages after
      adding, editing, or deleting a language. The purpose is to refresh the
      view, ensuring new and edited items are sorted into their correct
      positions and items marked as deleted are removed from the list.
    </p>
    <ul>
      <li>Clears outdated flash messages to avoid confusion.</li>
      <li>
        Reloads the data stream by calling <code>apply_options/4</code> with
        <code>reset_stream</code> set to <code>true</code>, ensuring the list
        reflects the latest server state.
      </li>
      <li>
        Guarantees a consistent view where all items appear in their proper
        places, providing a seamless user experience.
      </li>
    </ul>
  </li>
  <li>
    <strong>"delete"</strong>
    <p>Deletes a language and updates the UI to reflect the change.</p>
    <ul>
      <li>
        Upon successful deletion, calls <code>handle_deleted/2</code> to update
        counts, sets the <code>:pending_deletion</code> flag, and marks the
        language as deleted in the UI. The deleted language is not removed from
        the stream but marked with a <code>:deleted</code> flag, allowing it to
        remain visible until the user navigates away or refreshes.
      </li>
      <li>
        A flash message is displayed, including a link for the user to reload
        and sort the list. This encourages the user to update their view for
        consistency after changes.
      </li>
    </ul>
  </li>
</ul>
<h3><code>handle_info/2</code></h3>
<p>
  The <code>handle_info/2</code> functions handle asynchronous messages sent as
  tuples containing the sender module and the message itself. These messages can
  originate from form actions (like creating or updating a language) or from
  broadcasts triggered by other users' actions.
</p>
<h4>Form Updates</h4>
<ul>
  <li>
    <strong>Created by Current User:</strong>
    <p>
      When the form component emits a
      <code>{FormComponent, {:created, language}}</code> message, the LiveView
      invokes <code>handle_created/2</code> to update counts and insert the new
      language into the stream. A flash message with a reset link is then
      displayed, allowing the user to refresh and sort the list.
    </p>
  </li>
  <li>
    <strong>Updated by Current User:</strong>
    <p>
      Similarly, when the form component sends a
      <code>{FormComponent, {:updated, language}}</code> message,
      <code>handle_updated/2</code> is called to update the language in the
      stream. A flash message confirms the successful update to the user.
    </p>
  </li>
</ul>
<h4>Broadcasted Updates</h4>
<ul>
  <li>
    <strong>Created by Another User:</strong>
    <p>
      When another user creates a language, a
      <code>{Languages2, {:created, language}}</code> broadcast is received. The
      LiveView uses <code>handle_created/2</code> to update counts and add the
      new language to the stream. A flash message with a reset link notifies the
      user of the new addition and prompts them to refresh and sort the list.
    </p>
  </li>
  <li>
    <strong>Updated by Another User:</strong>
    <p>
      Upon receiving a
      <code>{Languages2, {:updated, language}}</code> broadcast,
      <code>handle_updated/2</code> updates the language in the stream. A flash
      message informs the user that a language was updated by another user.
    </p>
  </li>
  <li>
    <strong>Deleted by Another User:</strong>
    <p>
      If a language is deleted by another user, a
      <code>{Languages2, {:deleted, language}}</code> message is received. The
      LiveView calls <code>handle_deleted/2</code> to update counts and mark the
      language as deleted in the stream. If the deleted language was being
      edited by the current user, a flash message notifies them of the deletion
      and closes the edit modal. Otherwise, a general flash message informs the
      user that the language has been deleted and will be removed upon
      navigation or refresh.
    </p>
  </li>
</ul>
<h3>
  <code>handle_deleted/2</code>, <code>handle_created/2</code>, and
  <code>handle_updated/2</code>
</h3>
<p>
  The functions <code>handle_deleted/2</code>, <code>handle_created/2</code>,
  and <code>handle_updated/2</code> are abstracted into separate functions to
  avoid code duplication. Both <code>handle_event/3</code> (user-initiated
  actions) and <code>handle_info/2</code> (broadcasted actions from other users)
  utilize these functions.
</p>
<h4>Core Concepts</h4>
<ul>
  <li>
    <strong>Flagging Items:</strong>
    <p>
      Each function adds a specific flag to the language
      struct—<code>:created</code>, <code>:updated</code>, or
      <code>:deleted</code>. These flags enable the UI to visually distinguish
      items by applying badges and colors, providing immediate feedback on their
      status.
    </p>
  </li>
  <li>
    <strong>Updating Counts:</strong>
    <p>
      They adjust various count assignments such as <code>:count_all</code>,
      <code>:count_all_summary</code>, and <code>:count_all_pagination</code>.
      These counts ensure that summaries and pagination controls accurately
      reflect the current state of the data. For a detailed explanation of how
      these counts work, refer to the <code>init/2</code> section.
    </p>
  </li>
</ul>
<h3>Helper Functions</h3>
<ul>
  <li>
    <strong><code>get_pagination_url/2</code></strong>
    <p>
      Generates URLs for accessing the current page, used when opening or
      closing modals, navigating back, and other pagination-related actions.
    </p>
  </li>
  <li>
    <strong><code>get_page_summary/4</code></strong>
    <p>
      Creates the summary text displayed above the data table, such as "Showing
      1 - 5 of 100."
    </p>
  </li>
  <li>
    <strong><code>format_percentage/2</code></strong>
    <p>
      Formats numerical values into percentage strings with specified precision.
      Applied within table cells and detailed views to present percentage data
      clearly.
    </p>
  </li>
</ul>
