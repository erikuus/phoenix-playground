<p>
  The
  <code>LivePlaygroundWeb.StepsLive.Filtered.Index</code> demonstrates how to
  coordinate pagination, sorting, and filtering functionality in a LiveView
  module using functional helper modules.
</p>

<p>
  The key insight is that these helpers must work together in a specific
  sequence because filtering affects record counts, which pagination needs for
  calculating valid page ranges.
</p>

<ul>
  <li>
    <strong>FilteringHelpers</strong>: Processes search criteria with type
    conversion and validation
  </li>
  <li>
    <strong>SortingHelpers</strong>: Manages column sorting with direction
    indicators
  </li>
  <li>
    <strong>PaginationHelpers</strong>: Controls page navigation with dynamic
    page calculations
  </li>
</ul>

<h3><code>mount/3</code></h3>
<p>
  The mount function follows a carefully orchestrated sequence that handles the
  interdependencies between filtering, sorting, and pagination.
</p>

<h4>Context Configuration</h4>
<p>
  Each helper requires its configuration before processing parameters. The
  filtering context is the most complex because it defines field-specific types,
  defaults, and validation rules. For detailed information about each helper's
  context structure, see the individual helper explanations.
</p>

<h4>Parameter Processing Pipeline</h4>
<p>
  The mount function processes URL parameters through a carefully orchestrated
  sequence that handles the interdependencies between filtering, sorting, and
  pagination. The key challenge is that we cannot use a single pipeline for both
  conversion and validation.
</p>
<ul>
  <li>
    <strong>Why conversion can use one pipeline:</strong> Each helper converts
    only parameters relevant to its domain, then passes the parameters to the
    next helper. Since conversion doesn't require interdependent data, all three
    helpers can process sequentially in a single pipeline.
  </li>

  <li>
    <strong>Why validation requires breaking the pipeline:</strong> Pagination
    validation needs an accurate record count based on valid filter options.
    This means we cannot validate pagination until filtering is completely
    validated and the database count is recalculated with the new filter
    criteria.
  </li>
</ul>
<p>
  The critical comparison <code>if options != valid_options do</code> detects
  any differences between original converted parameters and final validated
  ones. When differences exist, <code>push_navigate</code> redirects to the
  corrected URL, ensuring users see clean, valid URLs that reflect the actual
  application state.
</p>

<h4>Initialization Sequence</h4>
<p>
  When no URL correction is needed, the mount function initializes all helper
  assigns and loads data:
</p>

<ul>
  <li>
    Each helper's <code>init_*</code> function returns assigns in a consistent
    tuple format
  </li>
  <li>
    <code>FilteredLanguages.list_languages/1</code> receives the final validated
    options
  </li>
  <li>
    The stream is populated with initial data matching all current parameters
  </li>
</ul>

<h3><code>apply_action/3</code></h3>
<p>
  Handles different LiveView routes and clears previous state appropriately. For
  the index action, it calls <code>apply_options/3</code> to process URL
  parameters and determine if data needs reloading.
</p>

<h3><code>apply_options/3</code></h3>
<p>
  The core purpose of <code>apply_options/3</code> is to determine if filter,
  sorting, or pagination options have changed due to user UI interactions, and
  whether the data stream needs to be reset accordingly. It answers the
  question: "Has something changed that requires fetching fresh data from the
  database?"
</p>

<p>The function is called in these scenarios:</p>
<ul>
  <li>
    User changes filter criteria (typing in search boxes, selecting dropdown
    values)
  </li>
  <li>User clicks column headers to change sorting</li>
  <li>User clicks pagination controls to change pages or items per page</li>
  <li>
    User returns from create/edit modal where options haven't changed but data
    might have
  </li>
  <li>
    User clicks a "reset" link to force data reload after background updates
  </li>
</ul>

<h4>How It Works: Sequential Helper Resolution</h4>
<p>
  It calls each helper's <code>resolve_*_changes</code> function one by one.
  Each helper examines its domain-specific parameters and returns either
  <code>{:reset_stream, valid_options}</code> if changes require data reloading,
  or <code>{:noreset_stream, valid_options}</code> if no reload is needed.
  Here's the key insight: only one helper detects changes in any single user
  interaction as users cannot change filtering, sorting, and pagination
  simultaneously.
</p>

<h4>The Clever Use of force_reset</h4>
<p>
  The <code>force_reset</code> parameter has two distinct purposes in this
  function:
</p>

<ol>
  <li>
    <strong>User-Initiated Reset</strong>: When users click "reload and sort
    now" links (displayed in flash messages after create, edit, or delete
    operations), <code>force_reset</code> is set to <code>true</code>. This
    overrides all helper logic and forces a complete data reload regardless of
    parameter changes.
  </li>
  <li>
    <strong>Cascading Reset Logic</strong>: When one helper detects changes
    requiring a reset, this need is passed to subsequent helpers as a forced
    reset. This ensures that if filtering changed, sorting and pagination
    helpers return <code>{:reset_stream, valid_options}</code> even though their
    own parameters didn't change.
  </li>
</ol>

<h4>Pagination URL Synchronization</h4>
<p>
  The <code>page_changed</code> flag is returned by
  <code>PaginationHelpers.resolve_pagination_changes/5</code>. Imagine you're on
  penultimate page 5 and delete all its items. If you try to go to last page 6,
  validation will adjust back to page 5 (now the last page), and the URL must be
  updated to keep
</p>

<h3><code>handle_event/3</code></h3>
<p>This function handles four main types of user interactions:</p>
<ul>
  <li>
    <strong>"filter"</strong>
    <p>
      When users type in search boxes or change filter dropdowns, we process the
      form data using <code>FilteringHelpers.update_filter_options/3</code> and
      <code>validate_options/2</code>. Note that this bypasses
      <code>apply_defaults</code> because form inputs represent explicit user
      choices. We then update the URL with <code>push_patch</code> to sync URL
      with the new filter state.
    </p>
  </li>
  <li>
    <strong>"change-per-page"</strong>
    <p>
      When users change how many items they want to see per page, two things
      happen: we update the options with the new value using
      <code>PaginationHelpers.update_per_page_option/3</code> and update the URL
      with <code>push_patch</code>. Having the correct settings in the URL means
      users can bookmark or share their preferred view.
    </p>
  </li>
  <li>
    <strong>"reset-stream"</strong>
    <p>
      After adding, editing, or deleting a language, users see a flash message
      with a "reset" link. Clicking this link fires the "reset-stream" action
      that:
    </p>
    <ul>
      <li>
        Gets fresh data by calling <code>apply_options/3</code> with
        <code>force_reset=true</code>, which ensures everything is in its proper
        sorted position
      </li>
      <li>
        Cleans up by removing old flash messages with <code>clear_flash()</code>
      </li>
    </ul>
  </li>
  <li>
    <strong>"delete"</strong>
    <p>When users delete a language, we handle it gracefully in two steps:</p>
    <ul>
      <li>
        First, we update all our counts and mark the item as deleted using
        <code>PaginationHelpers.process_deleted/2</code>, which returns updated
        counts in <code>new_assigns</code> and a
        <code>marked_language</code> with the <code>:deleted</code> flag set to
        true. The deleted item stays visible (but grayed out with strikethrough)
        until users navigate away or refresh.
      </li>
      <li>
        Then, we show a flash message with a reset link, encouraging users to
        refresh their view when they're ready to see the final, sorted list
        without the deleted item.
      </li>
    </ul>
  </li>
</ul>

<h3><code>handle_info/2</code></h3>
<p>Handles messages that come in asynchronously from two sources:</p>
<ul>
  <li>
    From form components when the current user creates or updates a language
  </li>
  <li>From broadcasts when other users make changes</li>
</ul>
<ol>
  <li>
    <h4>Form Updates (Current User's Actions)</h4>
    <ul>
      <li>
        <strong>Creating a Language:</strong>
        <p>
          When the form component emits a
          <code>{FormComponent, {:created, language}}</code> message, the
          LiveView invokes <code>PaginationHelpers.process_created/2</code> to
          update counts (incremented in <code>new_assigns</code>) and insert the
          new language into the stream. This function returns a
          <code>marked_language</code>—the new language record enriched with a
          <code>:created</code> flag set to <code>true</code> to indicate its
          newly created status. We then check if the item matches current
          filters using <code>FilteredLanguages.matches_filter?/2</code> to
          provide appropriate messaging. A flash message with a reset link is
          then displayed, allowing the user to refresh and sort.
        </p>
      </li>

      <li>
        <strong>Updating a Language:</strong>
        <p>
          Similarly, when the form component sends a
          <code>{FormComponent, {:updated, language}}</code> message,
          <code>PaginationHelpers.process_updated/1</code> is called to mark the
          language as updated in the stream. A flash message confirms the
          successful update to the user.
        </p>
      </li>
    </ul>
  </li>
  <li>
    <h4>Broadcast Updates (Other Users' Actions)</h4>
    <ul>
      <li>
        <strong>Someone Creates a Language:</strong>
        <p>
          A <code>{FilteredLanguages, {:created, language}}</code> broadcast is
          received. We first check if the language matches current filters using
          <code>FilteredLanguages.matches_filter?/2</code>. If it matches, the
          LiveView invokes <code>PaginationHelpers.process_created/2</code> to
          update counts—returning updated counts in
          <code>new_assigns</code> (with <code>count_all</code> incremented)—and
          to add the language to the stream. This helper also returns a
          <code>marked_language</code>, which is the new language record
          enriched with a <code>:created</code> flag set to <code>true</code> to
          indicate its newly created status. A flash message with a reset link
          notifies the user of the new addition and prompts them to refresh and
          sort the list. If it doesn't match filters, the update is ignored.
        </p>
      </li>
      <li>
        <strong>Someone Updates a Language:</strong>
        <p>
          Upon receiving a
          <code>{FilteredLanguages, {:updated, language}}</code> broadcast, we
          first check if the language.id is in socket.assigns.visible_ids. If it
          is, <code>PaginationHelpers.process_updated/1</code> marks the
          language as updated in the stream and a flash message informs the
          user. If not, the update is ignored since it doesn't affect the
          current page view. This optimization reduces unnecessary UI updates
          and improves performance in scenarios with many concurrent users.
        </p>
      </li>
      <li>
        <strong>Someone Deletes a Language:</strong>
        <p>
          If a language is deleted by another user, a
          <code>{FilteredLanguages, {:deleted, language}}</code> broadcast is
          received. If the deleted item was visible on the current page, the
          LiveView calls <code>PaginationHelpers.process_deleted/2</code> to
          update counts—returning updated counts in <code>new_assigns</code>—and
          to mark the language as deleted in the stream. This helper returns a
          <code>marked_language</code> with the <code>:deleted</code> flag set
          to <code>true</code>. Appropriate notifications are then shown: if the
          deleted language was being edited by the current user, a flash message
          notifies him of the deletion and closes the edit modal; otherwise, a
          general flash message informs the user that the language has been
          deleted and will be removed upon navigation or refresh. If the item
          wasn't visible on the current page, only the total count is updated.
        </p>
      </li>
    </ul>
  </li>
</ol>
